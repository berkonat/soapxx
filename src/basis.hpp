#ifndef _SOAP_BASIS_HPP
#define _SOAP_BASIS_HPP

#include <string>
#include <math.h>
#include <vector>
#include <fstream>

#include "base/exceptions.hpp"
#include "options.hpp"
#include "globals.hpp"
#include "structure.hpp"
#include "angularbasis.hpp"
#include "radialbasis.hpp"

namespace soap {

namespace ub = boost::numeric::ublas;

class Basis
{
public:
	Basis(Options *options) : _options(options) {
		GLOG() << "Configuring basis ..." << std::endl;
		// CONFIGURE RADIAL BASIS
		_radbasis = RadialBasisOutlet().create(_options->get<std::string>("radialbasis.type"));
		_radbasis->configure(*options);
		// CONFIGURE ANGULAR BASIS
		_angbasis = AngularBasisOutlet().create(_options->get<std::string>("angularbasis.type"));
		_angbasis->configure(*options);
	}
   ~Basis() {
		delete _radbasis;
		_radbasis = NULL;
		delete _angbasis;
		_angbasis = NULL;
   }
   RadialBasis *getRadBasis() { return _radbasis; }
   AngularBasis *getAngBasis() { return _angbasis; }
private:
	Options *_options;
	RadialBasis *_radbasis;
	AngularBasis *_angbasis;
};


class BasisExpansion
{
public:
	typedef ub::matrix< std::complex<double> > coeff_t;
	typedef ub::zero_matrix< std::complex<double> > coeff_zero_t;

	BasisExpansion(Basis *basis) :
		_basis(basis), _radbasis(basis->getRadBasis()), _angbasis(basis->getAngBasis()) {
		int L = _angbasis->L();
		int N = _radbasis->N();
        _radcoeff = RadialBasis::radcoeff_zero_t(N,L+1);
        _angcoeff = AngularBasis::angcoeff_zero_t((L+1)*(L+1));
        _coeff = coeff_zero_t(N,(L+1)*(L+1));
	}
    ~BasisExpansion() {
    	_basis = NULL;
    	_radbasis = NULL;
    	_angbasis = NULL;
    	_radcoeff.clear();
    	_angcoeff.clear();
    }
    coeff_t &getCoefficients() { return _coeff; }
    void computeCoefficients(double r, vec d, double weight, double sigma) {
        _radbasis->computeCoefficients(r, sigma, _radcoeff);
        _angbasis->computeCoefficients(d, r, _angcoeff);
        for (int n = 0; n != _radbasis->N(); ++n) {
        	for (int l = 0; l != _angbasis->L()+1; ++l) {
                for (int m = -l; m != l+1; ++m) {
                    _coeff(n, l*l+l+m) = _radcoeff(n,l)*_angcoeff(l*l+l+m);
                }
        	}
        }
        _coeff *= weight;
        return;
    }
    void add(BasisExpansion &other) {
		_coeff = _coeff + other._coeff;
	}
    void conjugate() {
    	for (int n = 0; n != _radbasis->N(); ++n) {
			for (int l = 0; l != _angbasis->L()+1; ++l) {
				for (int m = -l; m != l+1; ++m) {
					_coeff(n, l*l+l+m) = std::conj(_coeff(n, l*l+l+m));
				}
			}
		}
    }
    void writeDensityOnGrid(
		std::string filename,
		Options *options,
		Structure *structure,
		Particle *center,
		bool fromExpansion) {

		if (_angbasis == NULL || _radbasis == NULL) {
			throw soap::base::APIError("<BasisExpansion::writeDensityOnGrid> "
				"Object not linked against basis.");
		}

		int I = options->get<int>("densitygrid.N");
		int Nx = 2*I+1;
		int Ny = Nx;
		int Nz = Nx;

		double dx = options->get<double>("densitygrid.dx");
		double dy = dx;
		double dz = dx;

		double conv = soap::constants::ANGSTROM_TO_BOHR;

		vec r0 = -I * vec(dx,dy,dz);

		std::ofstream ofs;
		ofs.open(filename.c_str(), std::ofstream::out);
		if (!ofs.is_open()) {
			throw soap::base::IOError("Bad file handle: " + filename);
		}

		ofs << "DENSITY ON GRID" << std::endl;
		ofs << "Generated by BasisCoefficients::writeDensityOnGrid" << std::endl;
		ofs << boost::format("%1$d %2$+1.4f %3$+1.4f %4$+1.4f")
			% structure->particles().size() % (r0.x()*conv) % (r0.y()*conv) % (r0.z()*conv) << std::endl;
		ofs << boost::format("%1$d %2$+1.4f +0.0000 +0.0000") % Nx % (dx*conv) << std::endl;
		ofs << boost::format("%1$d +0.0000 %2$+1.4f +0.0000") % Ny % (dy*conv) << std::endl;
		ofs << boost::format("%1$d +0.0000 +0.0000 %2$+1.4f") % Nz % (dz*conv) << std::endl;

		Structure::particle_it_t pit;
		for (pit = structure->beginParticles(); pit != structure->endParticles(); ++pit) {
			 vec dr = structure->connect(center->getPos(), (*pit)->getPos());
			 ofs << boost::format("%1$d 0.0 %2$+1.4f %3$+1.4f %4$+1.4f\n")
				 % (*pit)->getTypeId() % (dr.x()*conv) % (dr.y()*conv) % (dr.z()*conv);
		}

		GLOG() << "Fill grid " << std::flush;
		double int_density_dr = 0.0;
		int ijk = 0;
		for (int i = -I; i <= I; ++i) {
			if (((i+I) % 5) == 0) GLOG() << "." << std::flush;
			for (int j = -I; j <= I; ++j) {
				for (int k = -I; k <= I; ++k) {
					double density_dr = 0.0;

					// Note that expansion is computed with respect to center-particle position:
					// Hence no shifting required
					vec dr(i*dx, j*dy, k*dz);
					double r = soap::linalg::abs(dr);
					vec d = dr/r;

					// DENSITY BASED ON EXPANSION
					if (fromExpansion) {
						BasisExpansion density_exp_dr(_basis);
						density_exp_dr.computeCoefficients(r, d, 1., 0.);
						density_exp_dr.conjugate();

						BasisExpansion::coeff_t &c_nlm_dr = density_exp_dr.getCoefficients();
						BasisExpansion::coeff_t &c_nlm = this->getCoefficients();
						// Something like this would be desirable to replace n-l-m loop below:
						//double density_dr = ub::inner_prod(c_nlm, c_nlm_dr);
						for (int n = 0; n < _radbasis->N(); ++n) {
							for (int l = 0; l <= _angbasis->L(); ++l) {
								for (int m = -l; m <= l; ++m) {
									double voxel_density_dr = (c_nlm(n, l*l+l+m)*c_nlm_dr(n, l*l+l+m)).real();
									density_dr += voxel_density_dr;
									int_density_dr += voxel_density_dr*dx*dy*dz;
								}
							}
						}
					}

					// DENSITY BASED ON SMEARED PARTICLES
					else {
						for (pit = structure->beginParticles(); pit != structure->endParticles(); ++pit) {
							 vec dr_center_particle = structure->connect(center->getPos(), (*pit)->getPos());
							 vec dr_particle_target = dr - dr_center_particle;
							 double r_particle_target = soap::linalg::abs(dr_particle_target);
							 double sigma = (*pit)->getSigma();
							 double weight = (*pit)->getWeight();
							 density_dr += weight*pow(1./(2.*M_PI*sigma*sigma), 1.5)
								 * exp(-r_particle_target*r_particle_target/(2*sigma*sigma));
						}
						int_density_dr += density_dr*dx*dy*dz;
					}

					ofs << density_dr << " ";
					ijk += 1;
					ijk = ijk % 6;
					if (ijk == 0) {
						ofs << std::endl;
					}

				}
			}
		}
		ofs.close();
		GLOG() << " Volume integral = " << int_density_dr << std::endl;
		return;
	}
    RadialBasis::radcoeff_t &getRadCoeffs() { return _radcoeff; }
    AngularBasis::angcoeff_t &getAngCoeffs() { return _angcoeff; }

private:
    Basis *_basis;
	RadialBasis *_radbasis;
	AngularBasis *_angbasis;

	RadialBasis::radcoeff_t _radcoeff; // access via (n,l)
	AngularBasis::angcoeff_t _angcoeff; // access via (l*l+l+m)
	coeff_t _coeff; // access via (n, l*l+l+m)
};



struct BasisCoefficients
{
	BasisCoefficients(RadialCoefficients &c_n, AngularCoefficients &c_lm)
	: _c_n(c_n), _c_lm(c_lm), _radbasis(NULL), _angbasis(NULL) {
		_c_nlm.resize(c_n.size(), c_lm.size());
		_c_nlm = ub::outer_prod(_c_n, _c_lm);
	}
	void linkBasis(RadialBasis *radbasis, AngularBasis *angbasis) {
		_radbasis = radbasis;
		_angbasis = angbasis;
	}
	std::complex<double> &get(int n, int l, int m) {
		if (_c_lm.checkSize(l, m) && _c_n.checkSize(n)) {
			return _c_nlm(n, l*l+l+m);
		}
		else {
			throw soap::base::OutOfRange("BasisCoefficients::get");
		}
	}
	void add(BasisCoefficients &other) {
		_c_nlm = _c_nlm + other._c_nlm;
	}

	void writeDensityOnGrid(
		std::string filename,
		Options *options,
		Structure *structure,
		Particle *center,
		bool fromExpansion) {

		if (_angbasis == NULL || _radbasis == NULL) {
			throw soap::base::APIError("<BasisCoefficients::writeDensityOnGrid> "
				"Object not linked against basis.");
		}

		int I = options->get<int>("densitygrid.N");
		int Nx = 2*I+1;
		int Ny = Nx;
		int Nz = Nx;

		double dx = options->get<double>("densitygrid.dx");
		double dy = dx;
		double dz = dx;

		double conv = soap::constants::ANGSTROM_TO_BOHR;

		vec r0 = -I * vec(dx,dy,dz); // center->getPos();

		std::ofstream ofs;
		ofs.open(filename.c_str(), std::ofstream::out);
		if (!ofs.is_open()) {
			throw soap::base::IOError("Bad file handle: " + filename);
		}

		ofs << "DENSITY ON GRID" << std::endl;
		ofs << "Generated by BasisCoefficients::writeDensityOnGrid" << std::endl;
		ofs << boost::format("%1$d %2$+1.4f %3$+1.4f %4$+1.4f")
			% structure->particles().size() % (r0.x()*conv) % (r0.y()*conv) % (r0.z()*conv) << std::endl;
		ofs << boost::format("%1$d %2$+1.4f +0.0000 +0.0000") % Nx % (dx*conv) << std::endl;
		ofs << boost::format("%1$d +0.0000 %2$+1.4f +0.0000") % Ny % (dy*conv) << std::endl;
		ofs << boost::format("%1$d +0.0000 +0.0000 %2$+1.4f") % Nz % (dz*conv) << std::endl;

		Structure::particle_it_t pit;
		for (pit = structure->beginParticles(); pit != structure->endParticles(); ++pit) {
			 vec dr = structure->connect(center->getPos(), (*pit)->getPos());
			 ofs << boost::format("%1$d 0.0 %2$+1.4f %3$+1.4f %4$+1.4f\n")
				 % (*pit)->getTypeId() % (dr.x()*conv) % (dr.y()*conv) % (dr.z()*conv);
		}

		GLOG() << "Fill grid " << std::flush;
		double int_density_dr = 0.0;
		int ijk = 0;
		for (int i = -I; i <= I; ++i) {
			if (((i+I) % 5) == 0) GLOG() << "." << std::flush;
			for (int j = -I; j <= I; ++j) {
				for (int k = -I; k <= I; ++k) {
					double density_dr = 0.0;

					// Note that expansion is computed with respect to center-particle position:
					// Hence no shifting required
					vec dr(i*dx, j*dy, k*dz);
					double r = soap::linalg::abs(dr);
					vec d = dr/r;

					// DENSITY BASED ON EXPANSION
					if (fromExpansion) {
						RadialCoefficients c_n_dr = _radbasis->computeCoefficients(r);
						AngularCoefficients c_lm_dr = _angbasis->computeCoefficients(d, r);
						c_lm_dr.conjugate();
						BasisCoefficients c_nlm_dr(c_n_dr, c_lm_dr);
						// Something like this would be desirable to replace n-l-m loop below:
						//double density_dr = ub::inner_prod(c_nlm, c_nlm_dr);
						for (int n = 0; n < _radbasis->N(); ++n) {
							for (int l = 0; l <= _angbasis->L(); ++l) {
								for (int m = -l; m <= l; ++m) {
									double voxel_density_dr = (this->get(n, l, m)*c_nlm_dr.get(n, l, m)).real();
									density_dr += voxel_density_dr;
									int_density_dr += voxel_density_dr*dx*dy*dz;
								}
							}
						}
					}

					// DENSITY BASED ON SMEARED PARTICLES
					else {
						for (pit = structure->beginParticles(); pit != structure->endParticles(); ++pit) {
							 vec dr_center_particle = structure->connect(center->getPos(), (*pit)->getPos());
							 vec dr_particle_target = dr - dr_center_particle;
							 double r_particle_target = soap::linalg::abs(dr_particle_target);
							 double sigma = 0.5;
							 density_dr += pow(1./(2.*M_PI*sigma*sigma), 1.5)
								 * exp(-r_particle_target*r_particle_target/(2*sigma*sigma));
						}
						int_density_dr += density_dr*dx*dy*dz;
					}

					ofs << density_dr << " ";
					ijk += 1;
					ijk = ijk % 6;
					if (ijk == 0) {
						ofs << std::endl;
					}

				}
			}
		}

		GLOG() << " Volume integral = " << int_density_dr << std::endl;

		ofs.close();

		return;
	}

	ub::matrix< std::complex<double> > _c_nlm;
	RadialCoefficients _c_n;
	AngularCoefficients _c_lm;
	RadialBasis *_radbasis;
	AngularBasis *_angbasis;
};

}

#endif
